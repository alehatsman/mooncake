package docgen

import (
	"fmt"
	"io"
	"strings"

	"github.com/alehatsman/mooncake/internal/actions"
)

// generatePlatformMatrix generates a platform support matrix table.
func (g *Generator) generatePlatformMatrix(w io.Writer) error {
	actionList := g.getActions()

	if len(actionList) == 0 {
		return fmt.Errorf("no actions found")
	}

	// Generate metadata header
	write(w, "<!-- Generated by mooncake docs generate -->\n")
	write(w, "<!-- Version: %s | Generated: %s -->\n\n", g.Version, g.Timestamp.Format("2006-01-02 15:04:05 MST"))

	// Define platforms to check
	platforms := []string{"linux", "darwin", "windows", "freebsd"}
	platformNames := []string{"Linux", "macOS", "Windows", "FreeBSD"}

	// Generate table header
	write(w, "| Action | %s |\n", strings.Join(platformNames, " | "))
	write(w, "|--------|%s|\n", strings.Repeat("-------|", len(platforms)))

	// Generate table rows
	for _, action := range actionList {
		write(w, "| %s |", action.Name)
		for _, platform := range platforms {
			if platformSupported(action, platform) {
				write(w, " ✓ |")
			} else {
				write(w, " ✗ |")
			}
		}
		write(w, "\n")
	}

	return nil
}

// generateCapabilities generates an action capabilities table.
func (g *Generator) generateCapabilities(w io.Writer) error {
	actionList := g.getActions()

	if len(actionList) == 0 {
		return fmt.Errorf("no actions found")
	}

	// Generate metadata header
	write(w, "<!-- Generated by mooncake docs generate -->\n")
	write(w, "<!-- Version: %s | Generated: %s -->\n\n", g.Version, g.Timestamp.Format("2006-01-02 15:04:05 MST"))

	// Generate table header
	write(w, "| Action | Category | Dry-Run | Become | Check Mode |\n")
	write(w, "|--------|----------|---------|--------|------------|\n")

	// Generate table rows
	for _, action := range actionList {
		write(w, "| %s | %s | %s | %s | %s |\n",
			action.Name,
			action.Category,
			boolToYesNo(action.SupportsDryRun),
			boolToYesNo(action.SupportsBecome),
			boolToYesNo(action.ImplementsCheck),
		)
	}

	return nil
}

// generateActionSummary generates detailed action summaries.
func (g *Generator) generateActionSummary(w io.Writer) error {
	actionList := g.getActions()

	if len(actionList) == 0 {
		return fmt.Errorf("no actions found")
	}

	// Generate metadata header
	write(w, "<!-- Generated by mooncake docs generate -->\n")
	write(w, "<!-- Version: %s | Generated: %s -->\n\n", g.Version, g.Timestamp.Format("2006-01-02 15:04:05 MST"))

	// Group by category
	categories := make(map[string][]actions.ActionMetadata)
	for _, action := range actionList {
		category := string(action.Category)
		if category == "" {
			category = "other"
		}
		categories[category] = append(categories[category], action)
	}

	// Generate summaries by category
	categoryOrder := []string{"command", "file", "system", "data", "network", "output", "other"}
	for _, category := range categoryOrder {
		actionsByCategory, exists := categories[category]
		if !exists || len(actionsByCategory) == 0 {
			continue
		}

		write(w, "## %s\n\n", titleCase(category))

		for _, action := range actionsByCategory {
			write(w, "### %s\n\n", action.Name)

			if action.Description != "" {
				write(w, "**Description**: %s\n\n", action.Description)
			}

			write(w, "**Properties**:\n")
			write(w, "- Category: `%s`\n", action.Category)

			if len(action.SupportedPlatforms) > 0 {
				write(w, "- Platforms: %s\n", strings.Join(action.SupportedPlatforms, ", "))
			} else {
				write(w, "- Platforms: all\n")
			}

			write(w, "- Supports Dry-Run: %s\n", boolToYesNo(action.SupportsDryRun))
			write(w, "- Supports Become: %s\n", boolToYesNo(action.SupportsBecome))
			write(w, "- Implements Check: %s\n", boolToYesNo(action.ImplementsCheck))

			if action.Version != "" {
				write(w, "- Version: %s\n", action.Version)
			}

			if len(action.EmitsEvents) > 0 {
				write(w, "- Events: %s\n", strings.Join(action.EmitsEvents, ", "))
			}

			write(w, "\n")
		}
	}

	return nil
}

// boolToYesNo converts a boolean to Yes/No string.
func boolToYesNo(b bool) string {
	if b {
		return "Yes"
	}
	return "No"
}

// titleCase converts a string to title case (first letter uppercase).
func titleCase(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}
