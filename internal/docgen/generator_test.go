package docgen

import (
	"bytes"
	"strings"
	"testing"
	"time"

	_ "github.com/alehatsman/mooncake/internal/register" // Register all actions
)

func TestNewGenerator(t *testing.T) {
	version := "v1.0.0"
	gen := NewGenerator(version)

	if gen.Version != version {
		t.Errorf("expected version %s, got %s", version, gen.Version)
	}

	if gen.Timestamp.IsZero() {
		t.Error("expected non-zero timestamp")
	}
}

func TestGeneratePlatformMatrix(t *testing.T) {
	gen := NewGenerator("test")
	gen.Timestamp = time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC)

	var buf bytes.Buffer
	err := gen.generatePlatformMatrix(&buf)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	output := buf.String()

	// Check for metadata comments
	if !strings.Contains(output, "<!-- Generated by mooncake docs generate -->") {
		t.Error("missing generation comment")
	}

	if !strings.Contains(output, "<!-- Version: test") {
		t.Error("missing version in comment")
	}

	// Check for table structure
	if !strings.Contains(output, "| Action | Linux | macOS | Windows | FreeBSD |") {
		t.Error("missing table header")
	}

	if !strings.Contains(output, "|--------|") {
		t.Error("missing table separator")
	}

	// Check that some actions are present (should have at least a few registered)
	lines := strings.Split(output, "\n")
	actionRows := 0
	for _, line := range lines {
		if strings.HasPrefix(line, "|") && !strings.Contains(line, "Action") && !strings.Contains(line, "---") {
			actionRows++
		}
	}

	if actionRows == 0 {
		t.Error("no action rows found in output")
	}
}

func TestGenerateCapabilities(t *testing.T) {
	gen := NewGenerator("test")

	var buf bytes.Buffer
	err := gen.generateCapabilities(&buf)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	output := buf.String()

	// Check for table structure
	if !strings.Contains(output, "| Action | Category | Dry-Run | Become | Check Mode |") {
		t.Error("missing capabilities table header")
	}

	// Check for Yes/No values
	if !strings.Contains(output, "Yes") && !strings.Contains(output, "No") {
		t.Error("missing Yes/No values")
	}
}

func TestGenerateActionSummary(t *testing.T) {
	gen := NewGenerator("test")

	var buf bytes.Buffer
	err := gen.generateActionSummary(&buf)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	output := buf.String()

	// Check for category headers
	if !strings.Contains(output, "## Command") && !strings.Contains(output, "## File") {
		t.Error("missing category headers")
	}

	// Check for properties section
	if !strings.Contains(output, "**Properties**:") {
		t.Error("missing properties section")
	}

	if !strings.Contains(output, "- Category:") {
		t.Error("missing category property")
	}
}

func TestGenerateSection(t *testing.T) {
	gen := NewGenerator("test")

	tests := []struct {
		name    string
		section string
		wantErr bool
	}{
		{"platform matrix", "platform-matrix", false},
		{"capabilities", "capabilities", false},
		{"action summary", "action-summary", false},
		{"schema", "schema", false},
		{"all sections", "all", false},
		{"invalid section", "invalid-section", true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var buf bytes.Buffer
			err := gen.GenerateSection(tt.section, &buf, "")

			if (err != nil) != tt.wantErr {
				t.Errorf("GenerateSection() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !tt.wantErr && buf.Len() == 0 {
				t.Error("expected non-empty output")
			}
		})
	}
}

func TestGenerateAll(t *testing.T) {
	gen := NewGenerator("test")

	var buf bytes.Buffer
	err := gen.generateAll(&buf)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	output := buf.String()

	// Check all sections are present
	if !strings.Contains(output, "# Platform Support Matrix") {
		t.Error("missing platform matrix section")
	}

	if !strings.Contains(output, "# Action Capabilities") {
		t.Error("missing capabilities section")
	}

	if !strings.Contains(output, "# Action Summary") {
		t.Error("missing action summary section")
	}

	// Check section separators
	if strings.Count(output, "\n---\n") < 2 {
		t.Error("missing section separators")
	}
}

func TestBoolToYesNo(t *testing.T) {
	tests := []struct {
		input bool
		want  string
	}{
		{true, "Yes"},
		{false, "No"},
	}

	for _, tt := range tests {
		got := boolToYesNo(tt.input)
		if got != tt.want {
			t.Errorf("boolToYesNo(%v) = %s, want %s", tt.input, got, tt.want)
		}
	}
}

func TestGenerateSchemaDoc(t *testing.T) {
	gen := NewGenerator("test")

	var buf bytes.Buffer
	err := gen.generateSchemaDoc(&buf)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	output := buf.String()

	// Check for expected sections
	if !strings.Contains(output, "## YAML Schema Documentation") {
		t.Error("missing schema documentation header")
	}

	if !strings.Contains(output, "### PresetDefinition") {
		t.Error("missing PresetDefinition section")
	}

	if !strings.Contains(output, "### PresetParameter") {
		t.Error("missing PresetParameter section")
	}

	if !strings.Contains(output, "### PresetInvocation") {
		t.Error("missing PresetInvocation section")
	}

	// Check for fields table
	if !strings.Contains(output, "| Field | Type | Required | Description |") {
		t.Error("missing fields table")
	}

	// Check for example YAML
	if !strings.Contains(output, "**Example YAML**:") {
		t.Error("missing example YAML section")
	}
}
