package docgen

import (
	"fmt"
	"io"
	"reflect"
	"strings"

	"github.com/alehatsman/mooncake/internal/config"
)

// generateSchemaDoc generates YAML schema documentation from Go structs.
func (g *Generator) generateSchemaDoc(w io.Writer) error {
	// Generate metadata header
	write(w, "<!-- Generated by mooncake docs generate -->\n")
	write(w, "<!-- Version: %s | Generated: %s -->\n\n", g.Version, g.Timestamp.Format("2006-01-02 15:04:05 MST"))

	write(w, "## YAML Schema Documentation\n\n")
	write(w, "The following schemas are generated from Go struct definitions.\n")
	write(w, "All field names and types are guaranteed to match the implementation.\n\n")

	// Generate preset definition schema
	if err := g.generateStructSchema(w, "PresetDefinition", reflect.TypeOf(config.PresetDefinition{})); err != nil {
		return err
	}

	write(w, "\n---\n\n")

	// Generate preset parameter schema
	if err := g.generateStructSchema(w, "PresetParameter", reflect.TypeOf(config.PresetParameter{})); err != nil {
		return err
	}

	write(w, "\n---\n\n")

	// Generate preset invocation schema
	return g.generateStructSchema(w, "PresetInvocation", reflect.TypeOf(config.PresetInvocation{}))
}

// generateStructSchema generates schema documentation for a single struct.
func (g *Generator) generateStructSchema(w io.Writer, structName string, t reflect.Type) error {
	write(w, "### %s\n\n", structName)

	// Get struct documentation from comments (if available)
	switch structName {
	case "PresetDefinition":
		write(w, "Defines a reusable preset with parameters and steps.\n\n")
	case "PresetParameter":
		write(w, "Defines a parameter that can be passed to a preset.\n\n")
	case "PresetInvocation":
		write(w, "Invokes a preset in a playbook (user-facing syntax).\n\n")
	}

	// Generate fields table
	write(w, "**Fields**:\n\n")
	write(w, "| Field | Type | Required | Description |\n")
	write(w, "|-------|------|----------|-------------|\n")

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)

		// Skip unexported fields
		if !field.IsExported() {
			continue
		}

		// Skip fields marked with yaml:"-"
		yamlTag := field.Tag.Get("yaml")
		if yamlTag == "-" {
			continue
		}

		// Get YAML field name
		yamlName := strings.Split(yamlTag, ",")[0]
		if yamlName == "" {
			yamlName = strings.ToLower(field.Name)
		}

		// Get field type
		fieldType := formatFieldType(field.Type)

		// Check if required (fields without omitempty are required)
		required := "No"
		if !strings.Contains(yamlTag, "omitempty") && fieldType != "[]Step" {
			required = "Yes"
		}

		// Get description from json tag or generate one
		description := getFieldDescription(structName, field.Name)

		write(w, "| `%s` | %s | %s | %s |\n", yamlName, fieldType, required, description)
	}

	// Generate example YAML
	write(w, "\n**Example YAML**:\n\n")
	write(w, "```yaml\n")
	g.generateYAMLExample(w, structName, t, 0)
	write(w, "```\n")

	return nil
}

// generateYAMLExample generates example YAML for a struct.
func (g *Generator) generateYAMLExample(w io.Writer, structName string, t reflect.Type, indent int) {
	indentStr := strings.Repeat("  ", indent)

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)

		// Skip unexported fields
		if !field.IsExported() {
			continue
		}

		// Skip fields marked with yaml:"-"
		yamlTag := field.Tag.Get("yaml")
		if yamlTag == "-" {
			continue
		}

		// Get YAML field name
		yamlName := strings.Split(yamlTag, ",")[0]
		if yamlName == "" {
			yamlName = strings.ToLower(field.Name)
		}

		// Check if optional
		isOptional := strings.Contains(yamlTag, "omitempty")

		// Get example value
		exampleValue := getExampleValue(structName, field.Name, field.Type)

		if isOptional && exampleValue == "" {
			continue // Skip optional fields with no example
		}

		// Special handling for Steps field
		if field.Name == "Steps" {
			write(w, "%s%s:\n", indentStr, yamlName)
			write(w, "%s  - name: Example step\n", indentStr)
			write(w, "%s    shell: echo \"hello\"\n", indentStr)
			continue
		}

		// Special handling for Parameters map
		if field.Name == "Parameters" && structName == "PresetDefinition" {
			write(w, "%s%s:\n", indentStr, yamlName)
			write(w, "%s  param_name:\n", indentStr)
			write(w, "%s    type: string\n", indentStr)
			write(w, "%s    required: true\n", indentStr)
			write(w, "%s    description: Parameter description\n", indentStr)
			continue
		}

		// Special handling for With map
		if field.Name == "With" && structName == "PresetInvocation" {
			write(w, "%s%s:\n", indentStr, yamlName)
			write(w, "%s  param1: value1\n", indentStr)
			write(w, "%s  param2: value2\n", indentStr)
			continue
		}

		write(w, "%s%s: %s\n", indentStr, yamlName, exampleValue)
	}
}

// formatFieldType formats a reflect.Type as a readable string.
func formatFieldType(t reflect.Type) string {
	switch t.Kind() {
	case reflect.String:
		return "string"
	case reflect.Bool:
		return "bool"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return "int"
	case reflect.Float32, reflect.Float64:
		return "float"
	case reflect.Slice:
		elemType := formatFieldType(t.Elem())
		return fmt.Sprintf("[]%s", elemType)
	case reflect.Map:
		keyType := formatFieldType(t.Key())
		valueType := formatFieldType(t.Elem())
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
	case reflect.Ptr:
		return "*" + formatFieldType(t.Elem())
	case reflect.Struct:
		return t.Name()
	case reflect.Interface:
		return "interface{}"
	default:
		return t.String()
	}
}

// getFieldDescription returns a description for a field.
func getFieldDescription(structName, fieldName string) string {
	descriptions := map[string]map[string]string{
		"PresetDefinition": {
			"Name":        "Unique preset identifier",
			"Description": "Human-readable description of what the preset does",
			"Version":     "Semantic version (e.g., 1.0.0)",
			"Parameters":  "Map of parameter definitions",
			"Steps":       "Array of steps to execute",
			"BaseDir":     "Base directory for path resolution (set by loader)",
		},
		"PresetParameter": {
			"Type":        "Parameter type (string, bool, array, object)",
			"Required":    "Whether the parameter must be provided",
			"Default":     "Default value if not provided",
			"Enum":        "List of valid values (if restricted)",
			"Description": "Human-readable parameter description",
		},
		"PresetInvocation": {
			"Name": "Name of the preset to invoke",
			"With": "Map of parameter values to pass to preset",
		},
	}

	if structDescs, ok := descriptions[structName]; ok {
		if desc, ok := structDescs[fieldName]; ok {
			return desc
		}
	}

	return ""
}

// getExampleValue returns an example value for a field.
func getExampleValue(structName, fieldName string, fieldType reflect.Type) string {
	examples := map[string]map[string]string{
		"PresetDefinition": {
			"Name":        "my-preset",
			"Description": "Description of what this preset does",
			"Version":     "1.0.0",
		},
		"PresetParameter": {
			"Type":        "string",
			"Required":    "true",
			"Description": "Description of the parameter",
		},
		"PresetInvocation": {
			"Name": "my-preset",
		},
	}

	if structExamples, ok := examples[structName]; ok {
		if example, ok := structExamples[fieldName]; ok {
			return example
		}
	}

	// Default examples by type
	switch fieldType.Kind() {
	case reflect.String:
		return `"value"`
	case reflect.Bool:
		return "false"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return "0"
	default:
		return ""
	}
}
